import { readFile, writeFile, mkdir } from "fs/promises";
import { resolve, relative } from "pathe";
import type { Nitro } from "nitro/types";
import { scan } from ".";
import { GeneratedHookTypes } from "../types";

export interface NovaTypeImport {
  moduleName: string;
  imports: string[];
}

const nitroImport: NovaTypeImport = {
  moduleName: "nitro/types",
  imports: [
    "Nitro",
    "Serialize",
    "Simplify",
    "NitroApp",
    "NitroRuntimeHooks",
    "NitroHooks",
  ],
};

const novaRuntimeImport: NovaTypeImport = {
  moduleName: "@gtc-nova/kit/runtime",
  imports: [],
};

const novaImport: NovaTypeImport = {
  moduleName: "@gtc-nova/kit",
  imports: [],
};

const generateTypeHeader = (moduleName: string) =>
  `// Generated by ${moduleName} with Nova\n`;

const createTypesDirectory = async (typesDir: string) => {
  try {
    await mkdir(typesDir, { recursive: true });
  } catch (e) {
    console.error("Error creating types directory:", e);
  }
};

const generateImportStatement = ({ moduleName, imports }: NovaTypeImport) =>
  `import type { ${imports.join(", ")} } from "${moduleName}";\n`;

const generateNitroModuleDeclaration = ({
  moduleName,
}: {
  moduleName: string;
}) => `
declare module "nitro/types" {
  interface NitroRuntimeHooks {
    'nova:${moduleName}:before': (nitroApp: NitroApp, payload: ${moduleName
  .charAt(0)
  .toUpperCase()}${moduleName.slice(1)}BeforeHookPayload) => ${moduleName
  .charAt(0)
  .toUpperCase()}${moduleName.slice(1)}BeforeHookReturn
    'nova:${moduleName}:after': (nitroApp: NitroApp, payload: ${moduleName
  .charAt(0)
  .toUpperCase()}${moduleName.slice(1)}AfterHookPayload) => ${moduleName
  .charAt(0)
  .toUpperCase()}${moduleName.slice(1)}AfterHookReturn
  }
  interface NitroHooks {
    'nova:${moduleName}:before': (nitro: Nitro) => any // todo
    'nova:${moduleName}:after': (nitro: Nitro) => any // todo
  }
}
`;

const generateNovaKitModuleDeclaration = (
  moduleName: string,
  features: Record<string, string>,
  typeExtension?: {
    hookTypes?: GeneratedHookTypes;
    imports: NovaTypeImport[];
  }
) => `
  

interface ${moduleName.charAt(0).toUpperCase()}${moduleName.slice(
  1
)}BeforeHookReturn {
  ${
    typeExtension?.hookTypes?.runtimeBeforeReturn &&
    Object.entries(typeExtension.hookTypes.runtimeBeforeReturn)
      .map(
        ([key, value]) => `
    ${key}: ${value}
  `
      )
      .join("\n")
  }
  }

  interface ${moduleName.charAt(0).toUpperCase()}${moduleName.slice(
  1
)}AfterHookReturn {
 ${
   typeExtension?.hookTypes?.runtimeAfterReturn &&
   Object.entries(typeExtension.hookTypes.runtimeAfterReturn)
     .map(
       ([key, value]) => `
    ${key}: ${value}
  `
     )
     .join("\n")
 }


  }

  interface ${moduleName.charAt(0).toUpperCase()}${moduleName.slice(
  1
)}BeforeHookPayload {
  ${
    typeExtension?.hookTypes?.runtimeBeforePayload &&
    Object.entries(typeExtension.hookTypes.runtimeBeforePayload)
      .map(
        ([key, value]) => `
    ${key}: ${value}
  `
      )
      .join("\n")
  }
  }

  interface ${moduleName.charAt(0).toUpperCase()}${moduleName.slice(
  1
)}AfterHookPayload {
 ${
   typeExtension?.hookTypes?.runtimeAfterPayload &&
   Object.entries(typeExtension.hookTypes.runtimeAfterPayload)
     .map(
       ([key, value]) => `
    ${key}: ${value}
  `
     )
     .join("\n")
 }
  }

  
declare module "@gtc-nova/kit" {
  type Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T

  interface NovaFeatures {
    ${moduleName}: {
      ${Object.entries(features)
        .map(
          ([featureName, _]) => `
      ${featureName}: ${
            featureName.charAt(0).toUpperCase() + featureName.slice(1)
          }Handlers
      `
        )
        .join("\n")}
    }
  }
}
`;

const generateFeatureHandlers = async (
  nitro: Nitro,
  featureName: string,
  featureFolder: string
) => {
  const scannedFeatures = await scan({
    nitro,
    feature: { name: featureName, folder: featureFolder },
  });
  const featuresName = `scanned${
    featureName.charAt(0).toUpperCase() + featureName.slice(1)
  }`;

  let content = `interface ${
    featureName.charAt(0).toUpperCase() + featureName.slice(1)
  }Handlers {\n`;

  for (const sc of scannedFeatures[
    featuresName as keyof typeof scannedFeatures
  ]) {
    const relativePath = relative(nitro.options.rootDir, sc.handler);
    content += `  '${sc.route}': typeof import('../../${relativePath}').default\n`;
  }

  content += `}\n`;
  return content;
};

export async function writeNovaTypes(
  nitro: Nitro,
  moduleName: string,
  features: Record<string, string>,
  typeExtension: {
    hookTypes?: GeneratedHookTypes;
    imports: NovaTypeImport[];
  }
) {
  const typesDir = resolve(nitro.options.buildDir, "types");
  const novaTypesPath = resolve(typesDir, `${moduleName}-types.d.ts`);

  await createTypesDirectory(typesDir);

  let content = generateTypeHeader(moduleName);
  content += generateImportStatement(nitroImport);
  content += generateImportStatement(novaRuntimeImport);
  content += generateImportStatement(novaImport);

  for (const imp of typeExtension.imports) {
    content += generateImportStatement(imp);
  }

  content += generateNitroModuleDeclaration({
    moduleName,
  });

  content += generateNovaKitModuleDeclaration(
    moduleName,
    features,
    typeExtension
  );

  for (const [featureName, featureFolder] of Object.entries(features)) {
    content += await generateFeatureHandlers(nitro, featureName, featureFolder);
  }

  await writeFile(novaTypesPath, content);
}
